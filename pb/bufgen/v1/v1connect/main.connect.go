// Language Guide (proto 3) | Protocol Buffers Documentation https://protobuf.dev/programming-guides/proto3/

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: v1/main.proto

package v1connect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	v1 "github.com/knaka/biblioseeq/pb/bufgen/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// MainServiceName is the fully-qualified name of the MainService service.
	MainServiceName = "v1.MainService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// MainServiceVersionInfoProcedure is the fully-qualified name of the MainService's VersionInfo RPC.
	MainServiceVersionInfoProcedure = "/v1.MainService/VersionInfo"
	// MainServiceStatusProcedure is the fully-qualified name of the MainService's Status RPC.
	MainServiceStatusProcedure = "/v1.MainService/Status"
	// MainServiceCurrentTimeProcedure is the fully-qualified name of the MainService's CurrentTime RPC.
	MainServiceCurrentTimeProcedure = "/v1.MainService/CurrentTime"
	// MainServiceQueryProcedure is the fully-qualified name of the MainService's Query RPC.
	MainServiceQueryProcedure = "/v1.MainService/Query"
	// MainServiceContentProcedure is the fully-qualified name of the MainService's Content RPC.
	MainServiceContentProcedure = "/v1.MainService/Content"
	// MainServiceOpenFileProcedure is the fully-qualified name of the MainService's OpenFile RPC.
	MainServiceOpenFileProcedure = "/v1.MainService/OpenFile"
	// MainServiceOpenURLProcedure is the fully-qualified name of the MainService's OpenURL RPC.
	MainServiceOpenURLProcedure = "/v1.MainService/OpenURL"
)

// MainServiceClient is a client for the v1.MainService service.
type MainServiceClient interface {
	VersionInfo(context.Context, *connect_go.Request[v1.VersionInfoRequest]) (*connect_go.Response[v1.VersionInfoResponse], error)
	Status(context.Context, *connect_go.Request[v1.StatusRequest]) (*connect_go.Response[v1.StatusResponse], error)
	CurrentTime(context.Context, *connect_go.Request[v1.CurrentTimeRequest]) (*connect_go.Response[v1.CurrentTimeResponse], error)
	Query(context.Context, *connect_go.Request[v1.QueryRequest]) (*connect_go.Response[v1.QueryResponse], error)
	Content(context.Context, *connect_go.Request[v1.ContentRequest]) (*connect_go.Response[v1.ContentResponse], error)
	OpenFile(context.Context, *connect_go.Request[v1.OpenFileRequest]) (*connect_go.Response[v1.OpenFileResponse], error)
	OpenURL(context.Context, *connect_go.Request[v1.OpenURLRequest]) (*connect_go.Response[v1.OpenURLResponse], error)
}

// NewMainServiceClient constructs a client for the v1.MainService service. By default, it uses the
// Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewMainServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) MainServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &mainServiceClient{
		versionInfo: connect_go.NewClient[v1.VersionInfoRequest, v1.VersionInfoResponse](
			httpClient,
			baseURL+MainServiceVersionInfoProcedure,
			opts...,
		),
		status: connect_go.NewClient[v1.StatusRequest, v1.StatusResponse](
			httpClient,
			baseURL+MainServiceStatusProcedure,
			opts...,
		),
		currentTime: connect_go.NewClient[v1.CurrentTimeRequest, v1.CurrentTimeResponse](
			httpClient,
			baseURL+MainServiceCurrentTimeProcedure,
			opts...,
		),
		query: connect_go.NewClient[v1.QueryRequest, v1.QueryResponse](
			httpClient,
			baseURL+MainServiceQueryProcedure,
			opts...,
		),
		content: connect_go.NewClient[v1.ContentRequest, v1.ContentResponse](
			httpClient,
			baseURL+MainServiceContentProcedure,
			opts...,
		),
		openFile: connect_go.NewClient[v1.OpenFileRequest, v1.OpenFileResponse](
			httpClient,
			baseURL+MainServiceOpenFileProcedure,
			opts...,
		),
		openURL: connect_go.NewClient[v1.OpenURLRequest, v1.OpenURLResponse](
			httpClient,
			baseURL+MainServiceOpenURLProcedure,
			opts...,
		),
	}
}

// mainServiceClient implements MainServiceClient.
type mainServiceClient struct {
	versionInfo *connect_go.Client[v1.VersionInfoRequest, v1.VersionInfoResponse]
	status      *connect_go.Client[v1.StatusRequest, v1.StatusResponse]
	currentTime *connect_go.Client[v1.CurrentTimeRequest, v1.CurrentTimeResponse]
	query       *connect_go.Client[v1.QueryRequest, v1.QueryResponse]
	content     *connect_go.Client[v1.ContentRequest, v1.ContentResponse]
	openFile    *connect_go.Client[v1.OpenFileRequest, v1.OpenFileResponse]
	openURL     *connect_go.Client[v1.OpenURLRequest, v1.OpenURLResponse]
}

// VersionInfo calls v1.MainService.VersionInfo.
func (c *mainServiceClient) VersionInfo(ctx context.Context, req *connect_go.Request[v1.VersionInfoRequest]) (*connect_go.Response[v1.VersionInfoResponse], error) {
	return c.versionInfo.CallUnary(ctx, req)
}

// Status calls v1.MainService.Status.
func (c *mainServiceClient) Status(ctx context.Context, req *connect_go.Request[v1.StatusRequest]) (*connect_go.Response[v1.StatusResponse], error) {
	return c.status.CallUnary(ctx, req)
}

// CurrentTime calls v1.MainService.CurrentTime.
func (c *mainServiceClient) CurrentTime(ctx context.Context, req *connect_go.Request[v1.CurrentTimeRequest]) (*connect_go.Response[v1.CurrentTimeResponse], error) {
	return c.currentTime.CallUnary(ctx, req)
}

// Query calls v1.MainService.Query.
func (c *mainServiceClient) Query(ctx context.Context, req *connect_go.Request[v1.QueryRequest]) (*connect_go.Response[v1.QueryResponse], error) {
	return c.query.CallUnary(ctx, req)
}

// Content calls v1.MainService.Content.
func (c *mainServiceClient) Content(ctx context.Context, req *connect_go.Request[v1.ContentRequest]) (*connect_go.Response[v1.ContentResponse], error) {
	return c.content.CallUnary(ctx, req)
}

// OpenFile calls v1.MainService.OpenFile.
func (c *mainServiceClient) OpenFile(ctx context.Context, req *connect_go.Request[v1.OpenFileRequest]) (*connect_go.Response[v1.OpenFileResponse], error) {
	return c.openFile.CallUnary(ctx, req)
}

// OpenURL calls v1.MainService.OpenURL.
func (c *mainServiceClient) OpenURL(ctx context.Context, req *connect_go.Request[v1.OpenURLRequest]) (*connect_go.Response[v1.OpenURLResponse], error) {
	return c.openURL.CallUnary(ctx, req)
}

// MainServiceHandler is an implementation of the v1.MainService service.
type MainServiceHandler interface {
	VersionInfo(context.Context, *connect_go.Request[v1.VersionInfoRequest]) (*connect_go.Response[v1.VersionInfoResponse], error)
	Status(context.Context, *connect_go.Request[v1.StatusRequest]) (*connect_go.Response[v1.StatusResponse], error)
	CurrentTime(context.Context, *connect_go.Request[v1.CurrentTimeRequest]) (*connect_go.Response[v1.CurrentTimeResponse], error)
	Query(context.Context, *connect_go.Request[v1.QueryRequest]) (*connect_go.Response[v1.QueryResponse], error)
	Content(context.Context, *connect_go.Request[v1.ContentRequest]) (*connect_go.Response[v1.ContentResponse], error)
	OpenFile(context.Context, *connect_go.Request[v1.OpenFileRequest]) (*connect_go.Response[v1.OpenFileResponse], error)
	OpenURL(context.Context, *connect_go.Request[v1.OpenURLRequest]) (*connect_go.Response[v1.OpenURLResponse], error)
}

// NewMainServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewMainServiceHandler(svc MainServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mainServiceVersionInfoHandler := connect_go.NewUnaryHandler(
		MainServiceVersionInfoProcedure,
		svc.VersionInfo,
		opts...,
	)
	mainServiceStatusHandler := connect_go.NewUnaryHandler(
		MainServiceStatusProcedure,
		svc.Status,
		opts...,
	)
	mainServiceCurrentTimeHandler := connect_go.NewUnaryHandler(
		MainServiceCurrentTimeProcedure,
		svc.CurrentTime,
		opts...,
	)
	mainServiceQueryHandler := connect_go.NewUnaryHandler(
		MainServiceQueryProcedure,
		svc.Query,
		opts...,
	)
	mainServiceContentHandler := connect_go.NewUnaryHandler(
		MainServiceContentProcedure,
		svc.Content,
		opts...,
	)
	mainServiceOpenFileHandler := connect_go.NewUnaryHandler(
		MainServiceOpenFileProcedure,
		svc.OpenFile,
		opts...,
	)
	mainServiceOpenURLHandler := connect_go.NewUnaryHandler(
		MainServiceOpenURLProcedure,
		svc.OpenURL,
		opts...,
	)
	return "/v1.MainService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case MainServiceVersionInfoProcedure:
			mainServiceVersionInfoHandler.ServeHTTP(w, r)
		case MainServiceStatusProcedure:
			mainServiceStatusHandler.ServeHTTP(w, r)
		case MainServiceCurrentTimeProcedure:
			mainServiceCurrentTimeHandler.ServeHTTP(w, r)
		case MainServiceQueryProcedure:
			mainServiceQueryHandler.ServeHTTP(w, r)
		case MainServiceContentProcedure:
			mainServiceContentHandler.ServeHTTP(w, r)
		case MainServiceOpenFileProcedure:
			mainServiceOpenFileHandler.ServeHTTP(w, r)
		case MainServiceOpenURLProcedure:
			mainServiceOpenURLHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedMainServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedMainServiceHandler struct{}

func (UnimplementedMainServiceHandler) VersionInfo(context.Context, *connect_go.Request[v1.VersionInfoRequest]) (*connect_go.Response[v1.VersionInfoResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("v1.MainService.VersionInfo is not implemented"))
}

func (UnimplementedMainServiceHandler) Status(context.Context, *connect_go.Request[v1.StatusRequest]) (*connect_go.Response[v1.StatusResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("v1.MainService.Status is not implemented"))
}

func (UnimplementedMainServiceHandler) CurrentTime(context.Context, *connect_go.Request[v1.CurrentTimeRequest]) (*connect_go.Response[v1.CurrentTimeResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("v1.MainService.CurrentTime is not implemented"))
}

func (UnimplementedMainServiceHandler) Query(context.Context, *connect_go.Request[v1.QueryRequest]) (*connect_go.Response[v1.QueryResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("v1.MainService.Query is not implemented"))
}

func (UnimplementedMainServiceHandler) Content(context.Context, *connect_go.Request[v1.ContentRequest]) (*connect_go.Response[v1.ContentResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("v1.MainService.Content is not implemented"))
}

func (UnimplementedMainServiceHandler) OpenFile(context.Context, *connect_go.Request[v1.OpenFileRequest]) (*connect_go.Response[v1.OpenFileResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("v1.MainService.OpenFile is not implemented"))
}

func (UnimplementedMainServiceHandler) OpenURL(context.Context, *connect_go.Request[v1.OpenURLRequest]) (*connect_go.Response[v1.OpenURLResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("v1.MainService.OpenURL is not implemented"))
}
