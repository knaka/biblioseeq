// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: file.sql

package sqlcgen

import (
	"context"
	"time"
)

const addFile = `-- name: AddFile :execlastid
INSERT INTO files (
  path,
  title,
  tags,
  fts_file_id,
  modified_at,
  size,
  updated_at
)
VALUES (
  ?1,
  ?2,
  ?3,
  ?4,
  ?5,
  ?6,
  current_timestamp
)
`

type AddFileParams struct {
	Path       string
	Title      string
	Tags       string
	FtsFileID  int64
	ModifiedAt time.Time
	Size       int64
}

func (q *Queries) AddFile(ctx context.Context, arg *AddFileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, addFile,
		arg.Path,
		arg.Title,
		arg.Tags,
		arg.FtsFileID,
		arg.ModifiedAt,
		arg.Size,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const addFtsFile = `-- name: AddFtsFile :execlastid
INSERT INTO fts_files (body) VALUES (?1)
`

type AddFtsFileParams struct {
	Body string
}

func (q *Queries) AddFtsFile(ctx context.Context, arg *AddFtsFileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, addFtsFile, arg.Body)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const deleteFiles = `-- name: DeleteFiles :exec
;

DELETE FROM files
WHERE
  CASE WHEN CAST(?1 AS text) IS NOT NULL THEN path = ?1 ELSE false END OR
  CASE WHEN CAST(?2 AS text) IS NOT NULL THEN
    path LIKE ?2 || '/%' or
    path LIKE ?2 || '\%'
  ELSE
    false
  END
`

type DeleteFilesParams struct {
	OptFilePath *string
	OptDirPath  *string
}

func (q *Queries) DeleteFiles(ctx context.Context, arg *DeleteFilesParams) error {
	_, err := q.db.ExecContext(ctx, deleteFiles, arg.OptFilePath, arg.OptDirPath)
	return err
}

const deleteFtsFiles = `-- name: DeleteFtsFiles :exec
;


DELETE FROM fts_files
WHERE rowid IN (
  SELECT fts_file_id
  FROM files
  WHERE
    CASE WHEN CAST(?1 AS text) IS NOT NULL THEN path = ?1 ELSE false END OR
    CASE WHEN CAST(?2 AS text) IS NOT NULL THEN
      path LIKE ?2 || '/%' or
      path LIKE ?2 || '\%'
    ELSE
      false
    END
)
`

type DeleteFtsFilesParams struct {
	OptFilePath *string
	OptDirPath  *string
}

func (q *Queries) DeleteFtsFiles(ctx context.Context, arg *DeleteFtsFilesParams) error {
	_, err := q.db.ExecContext(ctx, deleteFtsFiles, arg.OptFilePath, arg.OptDirPath)
	return err
}

const getFile = `-- name: GetFile :one
;

SELECT path, title, tags, fts_file_id, modified_at, size, updated_at FROM files WHERE path = ?1 LIMIT 1
`

type GetFileParams struct {
	Path string
}

func (q *Queries) GetFile(ctx context.Context, arg *GetFileParams) (*File, error) {
	row := q.db.QueryRowContext(ctx, getFile, arg.Path)
	var i File
	err := row.Scan(
		&i.Path,
		&i.Title,
		&i.Tags,
		&i.FtsFileID,
		&i.ModifiedAt,
		&i.Size,
		&i.UpdatedAt,
	)
	return &i, err
}

const getFileWithBody = `-- name: GetFileWithBody :one
SELECT files.path, files.title, files.tags, files.fts_file_id, files.modified_at, files.size, files.updated_at, fts_files.body
FROM
  files INNER JOIN
  fts_files ON files.fts_file_id = fts_files.rowid
WHERE
  files.path = ?1
LIMIT 1
`

type GetFileWithBodyParams struct {
	Path string
}

type GetFileWithBodyRow struct {
	File    File
	FtsFile FtsFile
}

func (q *Queries) GetFileWithBody(ctx context.Context, arg *GetFileWithBodyParams) (*GetFileWithBodyRow, error) {
	row := q.db.QueryRowContext(ctx, getFileWithBody, arg.Path)
	var i GetFileWithBodyRow
	err := row.Scan(
		&i.File.Path,
		&i.File.Title,
		&i.File.Tags,
		&i.File.FtsFileID,
		&i.File.ModifiedAt,
		&i.File.Size,
		&i.File.UpdatedAt,
		&i.FtsFile.Body,
	)
	return &i, err
}

const getFiles = `-- name: GetFiles :many
SELECT path, title, tags, fts_file_id, modified_at, size, updated_at FROM files
`

func (q *Queries) GetFiles(ctx context.Context) ([]*File, error) {
	rows, err := q.db.QueryContext(ctx, getFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Tags,
			&i.FtsFileID,
			&i.ModifiedAt,
			&i.Size,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const latestEntries = `-- name: LatestEntries :many
;

SELECT path, title, tags, fts_file_id, modified_at, size, updated_at
FROM files
ORDER BY files.modified_at DESC
LIMIT CASE WHEN CAST(?1 AS integer) > 0 THEN ?1 ELSE 50 END
`

type LatestEntriesParams struct {
	Limit int64
}

func (q *Queries) LatestEntries(ctx context.Context, arg *LatestEntriesParams) ([]*File, error) {
	rows, err := q.db.QueryContext(ctx, latestEntries, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.Path,
			&i.Title,
			&i.Tags,
			&i.FtsFileID,
			&i.ModifiedAt,
			&i.Size,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const query = `-- name: Query :many
;

SELECT files.path, files.title, files.tags, files.fts_file_id, files.modified_at, files.size, files.updated_at, snippet(fts_files, 0, '<b>', '</b>', '...', 30) as snippet
FROM
  files INNER JOIN
  fts_files ON files.fts_file_id = fts_files.rowid
WHERE
  fts_files.body MATCH ?1
ORDER BY rank
LIMIT CASE WHEN CAST(?2 AS integer) > 0 THEN ?2 ELSE 50 END
`

type QueryParams struct {
	Query string
	Limit int64
}

type QueryRow struct {
	File    File
	Snippet string
}

func (q *Queries) Query(ctx context.Context, arg *QueryParams) ([]*QueryRow, error) {
	rows, err := q.db.QueryContext(ctx, query, arg.Query, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*QueryRow
	for rows.Next() {
		var i QueryRow
		if err := rows.Scan(
			&i.File.Path,
			&i.File.Title,
			&i.File.Tags,
			&i.File.FtsFileID,
			&i.File.ModifiedAt,
			&i.File.Size,
			&i.File.UpdatedAt,
			&i.Snippet,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFile = `-- name: UpdateFile :exec
;

UPDATE files
SET
  title = ?1,
  tags = ?2,
  modified_at = ?3,
  size = ?4,
  updated_at = current_timestamp
WHERE
  path = ?5
`

type UpdateFileParams struct {
	Title      string
	Tags       string
	ModifiedAt time.Time
	Size       int64
	Path       string
}

func (q *Queries) UpdateFile(ctx context.Context, arg *UpdateFileParams) error {
	_, err := q.db.ExecContext(ctx, updateFile,
		arg.Title,
		arg.Tags,
		arg.ModifiedAt,
		arg.Size,
		arg.Path,
	)
	return err
}

const updateFtsFile = `-- name: UpdateFtsFile :exec
;

UPDATE fts_files
SET body = ?1
WHERE rowid = (
  SELECT fts_file_id FROM files WHERE path = ?2
)
`

type UpdateFtsFileParams struct {
	Body string
	Path string
}

func (q *Queries) UpdateFtsFile(ctx context.Context, arg *UpdateFtsFileParams) error {
	_, err := q.db.ExecContext(ctx, updateFtsFile, arg.Body, arg.Path)
	return err
}
